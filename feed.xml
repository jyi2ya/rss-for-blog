<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-cn">
  <id>http://16435056370.558509235127957/</id>
  <title>jyi2ya</title>
  <link rel="alternate" href="https://www.cnblogs.com/jyi2ya/" type="text/html"/>
  <subtitle>记录一些奇奇怪怪的东西</subtitle>
  <rights>Copyright &amp;copy; 2022 jyi2ya</rights>
  <generator>jyi2ya magic rss generator</generator>
  <link rel="self" href="http://orz.sto" type="application/atom+xml"/>
  <updated>2022-01-29T10:22:00+08:00Z</updated>
  <entry>
    <id>http://16435056370.508597627087635/</id>
    <title>markdown 中使用图片但是不使用图床</title>
    <link rel="alternate" href="https://www.cnblogs.com/jyi2ya/p/15854446.html" type="text/html"/>
    <summary type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">markdown 中使用图片但是不使用图床 起因是写博客要插入图片，但是懒得上传图片到图床。经过一番尝试后发现可以把图片 base64 编码后放进 markdown 语法中本应该放图片 url 的位置</div>
    </summary>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
<h1 id="markdown-中使用图片但是不使用图床">markdown 中使用图片但是不使用图床</h1>
<p>起因是写博客要插入图片，但是懒得上传图片到图床。经过一番尝试后发现可以把图片 base64 编码后放进 markdown 语法中本应该放图片 url 的位置，直接将图片插进 markdown 文件里。</p>
<p>显然我们需要找出 markdown 中的图片。为了减少图片大小，还需要缩放和压缩。为了偷懒想找找有没有相关的项目可以实现功能。只找到了 <a href="https://gitee.com/hujingnb/markdownImage" target="_blank" rel="noopener">markdownImage</a>。但是这个图片压缩好像是调用一些网站的 api 来完成相关功能的，还有免费次数限制，并且并不提供图片缩放功能。感觉和需求出入有点大……</p>
<p>最后我写了个便利脚本来完成这项任务，需要机器上安装了 imagemagick、base64 和 tr。</p>
<p>（这个脚本问题还是比较多，比如没有区分代码块里格式类似图片链接的部分和真正的图片链接，某些情况，比如 markdown 教程估计会锅掉。但是总之还是能用的嘛）</p>
<p>会从标准输入和命令行文件中读取内容，处理后输出到标准输出。（在后面接一个 clip 剪贴板程序就可以直接准备发布到博客园啦）</p>
<pre><code class="language-perl">#!/usr/bin/env perl

use v5.12;

sub process_image
{
	$_ = shift;
	if (/\.gif$/) {
		"data:image/gif;base64," .
		qx {
		convert -fuzz 15% -layers Optimize \Q$_\E - | base64 | tr -d '\n'
		}
	} else {
		"data:image/jpeg;base64," .
		qx {
		convert -resize \Q1280x960&gt;\E -strip -quality 75% \Q$_\E jpeg:- | base64 | tr -d '\n'
		}
	}
}

while (defined(my $line = &lt;&gt;)) {
	for ($line =~ /!\[[^\]]*\]\([^)]*\)/g) {
		my ($mark, $desc, $file) = /(!\[([^\]]*)\]\(([^)]*)\))/;
		$file = process_image $file;
		$line =~ s/\Q$mark\E/![$desc]($file)/;
	}
	print $line;
}
</code></pre>

</div>
    </content>
    <author>
      <name>jyi2ya</name>
    </author>
    <category term="note"/>
    <published>2022-01-29T10:22:00+08:00Z</published>
    <updated>2022-01-29T10:22:00+08:00Z</updated>
  </entry>
  <entry>
    <id>http://16435056370.428916038103985/</id>
    <title>CSAPP Data Lab 做题记录（上）</title>
    <link rel="alternate" href="https://www.cnblogs.com/jyi2ya/p/15854359.html" type="text/html"/>
    <summary type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">CSAPP Data Lab 做题记录（上） 准备工作 访问 http://csapp.cs.cmu.edu/3e/labs.html 试图下载网页上醒目的 datalab.tar，发现需要身份验证。</div>
    </summary>
    <content type="html">
&lt;h1 id="csapp-data-lab-做题记录上"&gt;CSAPP Data Lab 做题记录（上）&lt;/h1&gt;
&lt;h2 id="准备工作"&gt;准备工作&lt;/h2&gt;
&lt;p&gt;访问 &lt;a href="http://csapp.cs.cmu.edu/3e/labs.html" target="_blank" rel="noopener"&gt;http://csapp.cs.cmu.edu/3e/labs.html&lt;/a&gt; 试图下载网页上醒目的 datalab.tar，发现需要身份验证。后来发现点后面的小东西可以直接下载。读了 readme 之后知道 datalab.tar 好像是教师用的，用来生成学生的包（datalab-handout），datalab-handout 才是学生用的。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2022.cnblogs.com/blog/2737337/202201/2737337-20220129095613159-980089006.jpg" alt="datalab 的神秘链接" loading="lazy"&gt;&lt;/p&gt;
&lt;p&gt;读文档，知道实验是要用位运算来模拟各种整数运算，还要用整数运算模拟浮点运算。好像评测还实现了一个小工具来查是否用到了违规的操作符。&lt;/p&gt;
&lt;p&gt;看文档上说需要安装 bison 和 flex，以为检查违规小工具也需要编译，正打算看一下代码发现包里直接发了个二进制文件下来……&lt;/p&gt;
&lt;p&gt;发现评测程序是用 Perl 写的，古老。&lt;/p&gt;
&lt;p&gt;Driverlab.pm 里好像手写了一个 http 客户端？看起来是搞那个 Beat the Prof 比赛的，应该不用管它。&lt;/p&gt;
&lt;p&gt;依照手册指示，要先 make 一下把 btest 给编译好。结果遇到神奇问题：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;% 09:19:42 jyi@Syameimaru-Aya ~/s/c/d/c/d/datalab-handout
0 make
gcc -O -Wall -m32 -lm -o btest bits.c btest.c decl.c tests.c
In file included from btest.c:16:
/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory
   27 | #include &amp;lt;bits/libc-header-start.h&amp;gt;
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
In file included from decl.c:1:
/usr/include/stdio.h:27:10: fatal error: bits/libc-header-start.h: No such file or directory
   27 | #include &amp;lt;bits/libc-header-start.h&amp;gt;
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
In file included from /usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h:195,
                 from /usr/lib/gcc/x86_64-linux-gnu/10/include/syslimits.h:7,
                 from /usr/lib/gcc/x86_64-linux-gnu/10/include/limits.h:34,
                 from tests.c:3:
/usr/include/limits.h:26:10: fatal error: bits/libc-header-start.h: No such file or directory
   26 | #include &amp;lt;bits/libc-header-start.h&amp;gt;
      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~
compilation terminated.
make: *** [Makefile:11: btest] Error 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查了一发发现是 makefile 里指定了 &lt;code&gt;-m32&lt;/code&gt; 但是我没有 32 位的库，装了个 gcc-multilib。至于为啥不用 &lt;code&gt;-m64&lt;/code&gt; 编译……因为那里面说什么 "not 64-bit safe"，没太懂。&lt;/p&gt;
&lt;h2 id="题目列表"&gt;题目列表&lt;/h2&gt;
&lt;h3 id="bitxor"&gt;bitXor&lt;/h3&gt;
&lt;p&gt;给定两个数，返回他们的异或。&lt;/p&gt;
&lt;p&gt;首先由真值表写出把异或运算写成最小项之和的形式，就是 &lt;span class="math inline"&gt;\(X \oplus Y = X\bar{Y} + \bar{X}Y\)&lt;/span&gt;。然后跑跑发现零分，是因为我们没有 &lt;code&gt;|&lt;/code&gt; 可以用……用德摩根定律画画柿子得到 &lt;span class="math inline"&gt;\(\bar{\bar{X\bar{Y}}\bar{\bar{X}Y}}\)&lt;/span&gt;，避开 &lt;code&gt;|&lt;/code&gt;，就能过了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int bitXor(int x, int y) {
  return ~(~(~x &amp;amp; y) &amp;amp; ~(x &amp;amp; ~y));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="tmin"&gt;tmin&lt;/h3&gt;
&lt;p&gt;返回最小的有符号整数。&lt;/p&gt;
&lt;p&gt;题目假设机器使用补码表示法，我们知道这个数的位模式应该长得比较像 1000...000。题目又假设了我们机器上的整数都是 32 位的，所以我们把 1 左移 31 位返回就行了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int tmin(void) {
  return 1 &amp;lt;&amp;lt; 31;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="istmax"&gt;isTmax&lt;/h3&gt;
&lt;p&gt;判断给定的 x 是不是最大的有符号整数。&lt;/p&gt;
&lt;p&gt;考虑到题目假定机器采用补码表示法，最大的有符号整数 tmax 的位模式应该是 01111...111。好像把 tmin 的结果取反就是了，但是他没给 &lt;code&gt;&amp;lt;&amp;lt;&lt;/code&gt; 操作符，题目又禁止使用超过 255 的整数，所以 tmax 应该搞不出来。&lt;/p&gt;
&lt;p&gt;倒是有一个检查加一向上溢出（假设溢出的行为和无符号整数差不多）取反后是不是和自己相等（&lt;code&gt;~(x + 1) == x&lt;/code&gt;）的想法，但是有符号数溢出好像是 ub 啊。题目也没有规定溢出会采用什么方式。&lt;/p&gt;
&lt;p&gt;先这么做好了……-1 要特判一下因为 -1 取反加一后马上就溢出了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int isTmax(int x) {
  return (!((~(x + 1)) ^ x)) &amp;amp; (!!(x + 1));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="alloddbits"&gt;allOddBits&lt;/h3&gt;
&lt;p&gt;判断给定 x 的奇数二进制位上是否全为 1。&lt;/p&gt;
&lt;p&gt;……这样吗？&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int allOddBits(int x) {
  return (x &amp;gt;&amp;gt; 1) &amp;amp; (x &amp;gt;&amp;gt; 3) &amp;amp; (x &amp;gt;&amp;gt; 5) &amp;amp; (x &amp;gt;&amp;gt; 7) &amp;amp; (x &amp;gt;&amp;gt; 9) &amp;amp;
  (x &amp;gt;&amp;gt; 11) &amp;amp; (x &amp;gt;&amp;gt; 13) &amp;amp; (x &amp;gt;&amp;gt; 15) &amp;amp; (x &amp;gt;&amp;gt; 17) &amp;amp; (x &amp;gt;&amp;gt; 19) &amp;amp;
  (x &amp;gt;&amp;gt; 21) &amp;amp; (x &amp;gt;&amp;gt; 23) &amp;amp; (x &amp;gt;&amp;gt; 25) &amp;amp; (x &amp;gt;&amp;gt; 27) &amp;amp; (x &amp;gt;&amp;gt; 29) &amp;amp;
  (x &amp;gt;&amp;gt; 31) &amp;amp; 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;测了一下发现性能分数没有拿到，最多只能使用 12 个操作符，而这里用了 33 个。考虑进行优化。因为我们可以直接使用 8 位整数，所以我们可以考虑将输入的东西每 8 位与一下，再用一个掩码检查得到的东西奇数位上是否都为 1。这样就能减少计算了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int allOddBits(int x) {
  return !((x &amp;amp; (x &amp;gt;&amp;gt; 8) &amp;amp; (x &amp;gt;&amp;gt; 16) &amp;amp; (x &amp;gt;&amp;gt; 24) &amp;amp; 0xaa) ^ 0xaa);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;只用了 9 个操作符耶！&lt;/p&gt;
&lt;h3 id="negate"&gt;negate&lt;/h3&gt;
&lt;p&gt;求给定数的相反数。&lt;/p&gt;
&lt;p&gt;这个可以使用我们熟知的小结论，把 x 取反后再加一直接得到结果，非常简单。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int negate(int x) {
  return (~x) + 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3 id="isasciidigit"&gt;isAsciiDigit&lt;/h3&gt;
&lt;p&gt;判断给定输入是不是 ASCII 编码中的数字。&lt;/p&gt;
&lt;p&gt;我们已经有了比较两个数字是否相等的便利算法，只要打表检查是否等于每个可能的数字，将结果或起来就是最终答案。但是这样显然是拿不到性能分的嘛。&lt;/p&gt;
&lt;p&gt;嗯……如果 x 的最高位为 1，那它是个负数，就不是 ASCII 的数字了。排除这种情况后，接下来就只要考虑正数比大小。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;发现异或的结果的最高位是两个数字第一个不同之处，找出谁是 1 谁就更大。问题就变成了如何取一个数的最高位。&lt;/s&gt;并没有想到什么取一个数最高位的便利算法……&lt;/p&gt;
&lt;p&gt;考虑利用一下题目特性，ASCII 的 0 和 9 是 110000 和 111001，想到搞一个东西来检查 x 的前面 26 位是否全为 0，而且第 5、6 位为 1。接着再判断后四位是否符合第四位为 0，或者第 2、3 位为零……&lt;/p&gt;
&lt;p&gt;折腾一下得到这样的答案：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int isAsciiDigit(int x) {
  return (!((~0x3f) &amp;amp; x)) &amp;amp; (!((0x30 &amp;amp; x) ^ 0x30)) &amp;amp;
	  (!(0x8 &amp;amp; x) | (!(0x6 &amp;amp; x)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;轻松过关&lt;/p&gt;
&lt;h3 id="conditional"&gt;conditional&lt;/h3&gt;
&lt;p&gt;实现类似三目运算符的功能。&lt;/p&gt;
&lt;p&gt;要实现 &lt;code&gt;x ? y : z&lt;/code&gt; 的话，应该很容易想到 &lt;code&gt;(!!x) * y + (!x) * z&lt;/code&gt; 这种的……但是我们没有乘号。可以想到使用与号替代一下，就是想办法弄一个掩码，当 x 为真时它是全 1，x 为假时它是全零这种的。感觉比较简单。&lt;/p&gt;
&lt;p&gt;代码里为了节省符号把掩码弄成当 x 为真时是全 0，x 为假时是全 1。使用方法还是差不多的吧。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int conditional(int x, int y, int z) {
  int mask = !x;
  mask = (mask &amp;lt;&amp;lt; 1) | mask;
  mask = (mask &amp;lt;&amp;lt; 2) | mask;
  mask = (mask &amp;lt;&amp;lt; 4) | mask;
  mask = (mask &amp;lt;&amp;lt; 8) | mask;
  mask = (mask &amp;lt;&amp;lt; 16) | mask;
  return ((~mask) &amp;amp; y) | (mask &amp;amp; z);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;写后面的 howManyBits 的时候获得了重大技术革新，现在有一种便利操作来生成掩码了！&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int conditional(int x, int y, int z) {
  int mask = (~(!x)) + 1;
  return ((~mask) &amp;amp; y) | (mask &amp;amp; z);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 x 是 0，则 &lt;code&gt;~(!x)&lt;/code&gt; 位模式为 1111...1110，加 1 后刚好是全 1。&lt;/p&gt;
&lt;p&gt;如果 x 是 1，则 &lt;code&gt;~(!x)&lt;/code&gt; 位模式为 1111...1111，加 1 向上溢出后刚好是全 0。&lt;/p&gt;
&lt;h3 id="islessorequal"&gt;isLessOrEqual&lt;/h3&gt;
&lt;p&gt;判断给定的两个数是否满足小于等于关系。&lt;/p&gt;
&lt;p&gt;小于等于就是不大于嘛，接下来考虑判断两个数的大于关系。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;这个好像在 isAsciiDigit 那个题里的踩过一次，所以接着思路往下想……如何取一个数的最高位。&lt;/s&gt;发现取最高位的话怎么写都会拿不完性能分。&lt;/p&gt;
&lt;p&gt;突然想到好像两个数相减一下再判断结果是否为正数就行，原来刚刚想那么多是脑子打结了。&lt;/p&gt;
&lt;p&gt;先判断两个数是否正好为一正一负，如果是的话可以直接给结果。否则相减判断结果正负，这时两个同号的数相减必不可能溢出。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int isLessOrEqual(int x, int y) {
  return (((x &amp;gt;&amp;gt; 31) &amp;amp; 1) | (!(y &amp;gt;&amp;gt; 31))) &amp;amp;
	  ((((x &amp;gt;&amp;gt; 31) &amp;amp; 1) &amp;amp; (!(y &amp;gt;&amp;gt; 31))) | (!((y + (~x) + 1) &amp;gt;&amp;gt; 31)));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;拿下。&lt;/p&gt;
&lt;h3 id="logicalneg"&gt;logicalNeg&lt;/h3&gt;
&lt;p&gt;实现逻辑非，不能使用感叹号。&lt;/p&gt;
&lt;p&gt;感觉和 allOddBits 很像！只不过那个是求奇数位上全为 1，这里是求存在某一位为 1。&lt;/p&gt;
&lt;p&gt;用类似的方法实现一下就好啦。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int logicalNeg(int x) {
  x = x | (x &amp;gt;&amp;gt; 16);
  x = x | (x &amp;gt;&amp;gt; 8);
  x = x | (x &amp;gt;&amp;gt; 4);
  x = x | (x &amp;gt;&amp;gt; 2);
  x = x | (x &amp;gt;&amp;gt; 1);
  return 1 ^ (x &amp;amp; 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;最后 return 那个奇怪的表达式其实是 &lt;code&gt;1 - x&lt;/code&gt; 拆过来的。发现直接写 &lt;code&gt;2 + (~x)&lt;/code&gt; 会拿不到性能分，符号刚好多一个。&lt;/p&gt;
&lt;h3 id="howmanybits"&gt;howManyBits&lt;/h3&gt;
&lt;p&gt;求最少用多少个位可以表示出给定数字。&lt;/p&gt;
&lt;p&gt;其实就是 &lt;span class="math inline"&gt;\(\log_{2}\)&lt;/span&gt; 啦。&lt;/p&gt;
&lt;p&gt;先假定 x 是负数，根据补码表示法我们需要能够表示 &lt;span class="math inline"&gt;\([ x, -x - 1 ]\)&lt;/span&gt; 的所有数。全部当成无符号整数之后需要表示的范围是 &lt;span class="math inline"&gt;\([0, ((~x) &amp;lt;&amp;lt; 1) + 1]\)&lt;/span&gt;，只要我们能够用一些位表示出最大的数，那么这些位一定可以表示出所有数。因此答案就是 &lt;span class="math inline"&gt;\(\log_{2}(((~x) &amp;lt;&amp;lt; 1) + 1)\)&lt;/span&gt;（向上取整）。&lt;/p&gt;
&lt;p&gt;同理，如果 x 是正数，则需要能够表示 &lt;span class="math inline"&gt;\([ -x - 1, x ]\)&lt;/span&gt; 的所有数，答案是 &lt;span class="math inline"&gt;\(\log_{2}((x &amp;lt;&amp;lt; 1) + 1)\)&lt;/span&gt;。&lt;/p&gt;
&lt;p&gt;至于如何取对数……猜测是要使用类似 logicalNeg 和 allOddBits 那样类似分治（？）的做法来完成，先考虑分成两半的情形：如果高 16 位不为零，可以给答案加上 16，接着再把高 16 位移动到低 16 位，按照类似的方式处理低 16 位；如果高 16 位为零，则直接处理低 16 位。依次类推直到处理完只剩一位的情况。&lt;/p&gt;
&lt;p&gt;用力实现一下就好了。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;int howManyBits(int x) {
  int ans = 0;
  int h16, h8, h4, h2, h1, h0;
  int sign = x &amp;gt;&amp;gt; 31;
  int range = (((x &amp;amp; (~sign)) | ((~x) &amp;amp; sign)) &amp;lt;&amp;lt; 1) + 1;

  h16 = (~(!!(range &amp;gt;&amp;gt; 16))) + 1;
  ans = ans + (h16 &amp;amp; 16);
  range = range &amp;gt;&amp;gt; (h16 &amp;amp; 16);

  h8 = (~(!!((range &amp;gt;&amp;gt; 8) &amp;amp; 0xff))) + 1;
  ans = ans + (h8 &amp;amp; 8);
  range = range &amp;gt;&amp;gt; (h8 &amp;amp; 8);

  h4 = (~(!!((range &amp;gt;&amp;gt; 4) &amp;amp; 0xf))) + 1;
  ans = ans + (h4 &amp;amp; 4);
  range = range &amp;gt;&amp;gt; (h4 &amp;amp; 4);

  h2 = (~(!!((range &amp;gt;&amp;gt; 2) &amp;amp; 0x3))) + 1;
  ans = ans + (h2 &amp;amp; 2);
  range = range &amp;gt;&amp;gt; (h2 &amp;amp; 2);

  h1 = (~(!!((range &amp;gt;&amp;gt; 1) &amp;amp; 0x1))) + 1;
  ans = ans + (h1 &amp;amp; 1);
  range = range &amp;gt;&amp;gt; (h1 &amp;amp; 1);

  h0 = (~(range &amp;amp; 0x1)) + 1;
  ans = ans + (h0 &amp;amp; 1);

  return ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;真不容易！&lt;/p&gt;

</content>
    <author>
      <name>jyi2ya</name>
    </author>
    <category term="note"/>
    <published>2022-01-29T09:50:00+08:00Z</published>
    <updated>2022-01-29T09:50:00+08:00Z</updated>
  </entry>
  <entry>
    <id>http://16435056370.252290896035522/</id>
    <title>一些能够节省按键次数的 bash 配置</title>
    <link rel="alternate" href="https://www.cnblogs.com/jyi2ya/p/15845001.html" type="text/html"/>
    <summary type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">一些能够节省按键次数的 bash 配置 众所周知，敲击键盘的同时，人的手指会经历一系列的磨损。长此以往，手指就会变短。为了保护手指，使用下面的 bash 配置，成为和我一样能少按键盘就少按键盘的人吧！</div>
    </summary>
    <content type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">
<h1 id="一些能够节省按键次数的-bash-配置">一些能够节省按键次数的 bash 配置</h1>
<p>众所周知，敲击键盘的同时，人的手指会经历一系列的磨损。长此以往，手指就会变短。为了保护手指，使用下面的 bash 配置，成为和我一样能少按键盘就少按键盘的人吧！</p>
<h2 id="给命令起单个字符的别名">给命令起单个字符的别名</h2>
<p>对于一些常用的命令，如果没有重复命令，可以给他们起单个字符的别名。</p>
<pre><code class="language-bash">alias a='ls -A'
alias g='grep'
alias j='jobs -l'
alias l='ls'
alias o='xdg-open'
alias r='rm'
alias t='task' # taskwarrior: 一个 todo-list 小软件
alias v='vi'
alias -- -='cd -' # 这里的意思是将 - 作为 cd - 的别名
</code></pre>
<p>但是这些写法在 xargs 这里出了点小问题：</p>
<pre><code class="language-plain">% 17:51:28 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 alias x='xargs'
% 17:51:32 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 l|x g hello
xargs: g: No such file or directory
</code></pre>
<p>我们的本意是想让它运行</p>
<pre><code class="language-bash">ls | xargs grep hello
</code></pre>
<p>但由于 <code>g</code> 并不是命令，xargs 报了错。要是我们想让 <code>x</code> 被展开为 <code>xargs</code> 后，其后的 <code>g</code> 继续被展开，我们可以这样写：</p>
<pre><code class="language-bash">alias x='xargs ' # 注意，xargs 与第二个单引号之间有一个空格
</code></pre>
<p>之后再运行</p>
<pre><code class="language-plain">% 17:58:29 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
1 l
a.md
% 17:58:30 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
1 l|x g '`xargs`'
由于 `g` 并不是命令，xargs 报了错。要是我们想让 `x` 被展开为 `xargs` 后，其后的 `g` 继续被展开，我们可以这样写：
</code></pre>
<p>就好了。这是 bash 的小特性，结尾的空格可以让下一个标识符展开（如果是别名的话）。同理，我们对 <code>sudo</code> 也做类似的事情：</p>
<pre><code class="language-bash">alias s='sudo '
</code></pre>
<p>太方便辣！</p>
<p>此外，单个 <code>%</code> 的作用和 <code>fg</code> 相同，都是让后台进程回到前台。</p>
<h2 id="给有歧义的命令们起一样的名字">给有歧义的命令们起一样的名字</h2>
<p>我日常使用 <code>find</code> 和 <code>file</code> 比较频繁，正常人在缩写他们时，都会想到用 <code>f</code> 来作为它们的别名。而如果一个用 <code>f</code> 作了别名，另一个就只能用其他奇奇怪怪的缩写。有没有办法让它们共用一个名字呢？</p>
<p>由于脑机接口尚未开发完成，shell 无法通过魔法装置读取我们的思想，知道我们在运行 <code>f</code> 时究竟是想运行 <code>find</code>，还是 <code>file</code>，我们只能手动实现一个 shell 函数，根据上下文猜测输入时究竟想要什么。</p>
<p>（怎么有种 Perl 猜代码块和匿名哈希的感觉）</p>
<p>这是一个简单的示例，可以根据实际使用情况另作调整。</p>
<pre><code class="language-bash"># find, file
f()
{
	local i
	local expect_find=

	# 如果发现身处管道之中，stdin 里不是终端，有输入，则猜测想要
	# 确定 stdin 中文件的类型
	if ! [ -t 0 ]; then
		file -

	# 如果 stdin 是终端，但是没有参数，猜测是想要递归列出当前目录
	# 下的文件，调用 find
	elif [ -z "$1" ]; then
		find
	else

		# 如果有参数以连字符（-）打头，则猜测是 find 的参数，
		# 比如 -name -type 之类的。
		# 如果参数没有以连字符打头的，则猜测是 file 的参数，参数
		# 都是文件名
		for i in "$@"; do
			if [ "${i:0:1}" = '-' ]; then
				expect_find=y
				break
			fi
		done

		if [ -n "$expect_find" ]; then
			find "$@"
		else
			file "$@"
		fi
	fi
}
</code></pre>
<p>实际使用看起来还不错。</p>
<pre><code class="language-plain">% 18:56:38 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 f
.
./a.md
% 18:56:40 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 f &lt; a.md
/dev/stdin: UTF-8 Unicode text
% 18:56:42 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 f -type f
./a.md
% 18:56:45 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 f a.md
a.md: UTF-8 Unicode text
</code></pre>
<p>这样基本符合日常使用，无法处理的边边角角的情况打全名也不是不能接受啦。</p>
<p>还有一些类似的函数：</p>
<pre><code>c()
{
	# 复制？还是复制到剪贴板？
	if [ -t 0 ] &amp;&amp; [ "$#" -ge 2 ]; then
		cp "$@"
	else
		clip "$@"
	fi
}

p()
{
	# 调用分页器（pager）？还是打印当前目录？
	if [ -z "$1" ] &amp;&amp; [ -t 0 ]; then
		pwd
	else
		less -F "$@"
	fi
}
</code></pre>
<h2 id="给小工具更多的默认行为">给小工具更多的默认行为</h2>
<p>有时一些操作总是连在一起的，比如新建文件夹然后切换进去，我们可以用这样的神奇函数：</p>
<pre><code class="language-bash">md()
{
	if [ -z "$2" ]; then
		mkdir "$1" || return
		cd "$1"
	else
		mkdir "$@"
	fi
}
</code></pre>
<p>或者我们经常将别处的文件移到当前文件夹，使用这个函数，这样我们可以省略最后那个 <code>.</code> 参数。因为奇怪的原因，只有在有且仅有一个参数时才会有这个功能。有多个参数时总会有无法解决的歧义问题。（不过这样已经足够好了）</p>
<pre><code class="language-bash">m()
{
	if [ -z "$1" ]; then
		echo too few arguments
	elif [ -z "$2" ]; then
		mv "$1" .
	else
		mv "$@"
	fi
}
</code></pre>
<p>当然，执行 <code>cd</code> 再执行 <code>ls</code> 应该是某种常规的操作，每年因为这项操作没有优化，无数根手指被磨短。当然可以把 <code>cd</code> 变成 <code>cd &amp;&amp; ls</code>，但是我们想到了一种更加酷炫的方法来解决这个问题，放在另一个部分说。</p>
<h2 id="开启大量-shell-内置特性">开启大量 shell 内置特性</h2>
<p>bash 内置了大量方便的扩展特性，这些特性可以使用 <code>shopt -s &lt;特性名称&gt;</code> 打开。比如：<code>shopt -s autocd</code>。</p>
<h3 id="autocd">autocd</h3>
<p>自动切换目录……意思是假设当前目录下有一个名为 <code>my-doc</code> 的子目录，可以用 <code>my-doc</code> 取代 <code>cd my-doc</code>。这有一个小问题，由于补全时 bash 并不知道想输入的是目录还是指令，指令会和目录一起进入补全列表，又慢又难选。使用 <code>./my-doc</code> 会好很多。</p>
<h3 id="checkwinsize">checkwinsize</h3>
<p>在终端窗口变化时重新设置 <code>$LINES</code> 和 <code>$COLUMNS</code></p>
<h3 id="dotglob">dotglob</h3>
<p>匹配隐藏文件，这个按个人需求而定？我是觉得这个选项很酷所以打开了。</p>
<h3 id="extglob">extglob</h3>
<p>扩展的匹配，完全没用！真的好难用，试图给通配符加上一些正则表达式的扩展，还没有 <code>find</code> <code>sed</code> <code>grep</code> <code>xargs</code> 香。</p>
<h3 id="failglob">failglob</h3>
<p>没有匹配时报错而不是将模式作为参数传递给程序。非常有用，能避免一堆奇奇怪怪问题。比如：</p>
<p>开启前：</p>
<pre><code class="language-plain">% 19:21:49 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 touch *.c # 我要摸摸所有 c 文件
% 19:21:49 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 ls
 a.md  '*.c' # 啊不好了，他给我新建了一个 ./*.c
</code></pre>
<p>开启后：</p>
<pre><code class="language-plain">% 19:23:23 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 touch *.c
-bash: no match: *.c # 没有找到！
% [1] 19:23:28 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 ls
a.md
</code></pre>
<h3 id="globstar">globstar</h3>
<p>让 <code>**</code> 通配符支持递归进子文件夹的匹配，比如 my/**/file 可以匹配 my/magic/powerful/fancy/file ，可以用来部分代替 <code>find</code>。</p>
<h2 id="全自动的-ls">全自动的 ls</h2>
<p>有时我们希望当前目录下文件发生改变，或工作目录发生改变时，自动 <code>ls</code> 一下展示目录现状。</p>
<p>我们很容易写出这样的函数：</p>
<pre><code class="language-bash"># 第一次运行，保存工作目录和当前目录内容（的哈希值）
LAST_LS=$(command ls | sum)
LAST_PWD="$PWD"

_prompt_smart_ls()
{
	local this_ls
	this_ls=$(command ls | sum)
	if [ "$LAST_LS" != "$this_ls" ] || [ "$LAST_PWD" != "$PWD" ]; then
		LAST_LS="$this_ls"
		LAST_PWD="$PWD"
		ls
		return
	fi
}
</code></pre>
<p>之后，每调用一次 <code>_prompt_smart_ls</code>，它都会检查工作目录和当前目录内容，如果发现有不一样的地方，就 <code>ls</code> 一次。我们只要想办法每执行一次指令，就调用一次这个函数就行了。</p>
<p>（当然也可以用其他的检查方式，比如使用神奇的守护进程监视文件系统变化，再和 shell 通信，但是其他方法好像都没有每执行完一次指令就检查一次简单有效）</p>
<p>怎么做到每执行一次命令，就调用一次函数呢？</p>
<pre><code class="language-bash">PROMPT_COMMAND='_prompt_smart_ls'
</code></pre>
<p>使用 bash 魔法变量，bash 会在执行每条命令后自动执行 <code>PROMPT_COMMAND</code> 这个变量里所存的命令。</p>
<p>最后效果：</p>
<pre><code class="language-plain">% 20:17:09 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 touch test
a.md  test
% 20:17:12 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 rm test
a.md
% 20:17:13 jyi@Syameimaru-Aya ~/s/m/b/n/shell-abbr
0 cd /
bin/   dev/  home/  lib/    lost+found/  mnt/  proc/  run/   srv/  tmp/  var/
boot/  etc/  init*  lib64/  media/       opt/  root/  sbin/  sys/  usr/
</code></pre>
<p>太炫酷了！</p>
<h2 id="更多的-cd">更多的 cd</h2>
<p>我们知道设置了 <code>autocd</code> 之后，输入 <code>..</code> 会自动切换到上级目录……我们可以做得更多！</p>
<pre><code class="language-bash">alias ...='cd ../..'
alias ....='cd ../../../'
</code></pre>
<h2 id="使用外部工具">使用外部工具！</h2>
<p>仔细想了想，发现平时使用 <code>z.sh</code> 按访问频率自动跳转时，有时会跳转到自己不希望的位置，如果能够选择跳转到哪里就好了。</p>
<p>我们还需要可见的界面！这个想法是从 zsh 的补全里偷来的，感觉可以上下左右选择非常厉害。</p>
<p>所以使用 <code>fzf</code> 配合 <code>z.sh</code>，做出非常友好的跳转方式：</p>
<pre><code class="language-bash">fz()
{
	local dir
	dir="$(z | sed 's/^[0-9. \t]*//' |fzf -1 -0 --no-sort --tac +m)" &amp;&amp; \
		cd "$dir" || return 1
}
</code></pre>
<h2 id="正确的重新加载配置的方法">正确的重新加载配置的方法</h2>
<p>修改了 <code>.bashrc</code> 文件，想要试用一番！怎么加载配置文件呢？</p>
<p><code>source ~/.bashrc</code>：不好，前任配置文件中残留的 alias 尸体、环境变量可能会影响使用，尤其是写错了的情况下……</p>
<p><code>bash</code>：不好，退出的时候也要连按许多 exit 或者 Ctrl-D</p>
<p><code>bash; exit</code>：比上一个好，但是会影响 <code>$SHLVL</code> 变量，可能会对一些奇特脚本（比如 debian 11 下的 <code>~/.bash_logout</code>）造成影响。</p>
<p><code>exec bash</code>：非常好！用了 <code>exec bash</code>，亩产一千八！</p>
<p>所以这是重新加载配置文件的缩写（reload）：</p>
<pre><code class="language-bash">alias rl='exec bash'
</code></pre>
<h2 id="总结">总结</h2>
<blockquote>
<p>打键盘是不错，但是也别敲过了头。打键盘打得太多，手指可就被磨短了。</p>
</blockquote>

</div>
    </content>
    <author>
      <name>jyi2ya</name>
    </author>
    <category term="note"/>
    <published>2022-01-25T23:06:00+08:00Z</published>
    <updated>2022-01-25T23:06:00+08:00Z</updated>
  </entry>
  <entry>
    <id>http://16435056370.669515466302968/</id>
    <title>用盲文字符在终端画黑白图像</title>
    <link rel="alternate" href="https://www.cnblogs.com/jyi2ya/p/15844964.html" type="text/html"/>
    <summary type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">用盲文字符来在终端画黑白图像 食用提示 如果这篇文章在您的设备上显示很多方框，或许是字体出了问题。请确保自己使用的字体可以正常显示盲文。 在我的设备上，无论怎么操作都无法使 urxvt （rxvt ，</div>
    </summary>
    <content type="html">
&lt;h1 id="用盲文字符来在终端画黑白图像"&gt;用盲文字符来在终端画黑白图像&lt;/h1&gt;
&lt;h2 id="食用提示"&gt;食用提示&lt;/h2&gt;
&lt;p&gt;如果这篇文章在您的设备上显示很多方框，或许是字体出了问题。请确保自己使用的字体可以正常显示盲文。&lt;/p&gt;
&lt;p&gt;在我的设备上，无论怎么操作都无法使 urxvt （rxvt ， xterm ） 表现出我想要的样子。因此在不建议您进行实验时使用 urxvt （rxvt ， xterm ） 。&lt;/p&gt;
&lt;h2 id="想法来源"&gt;想法来源&lt;/h2&gt;
&lt;p&gt;有一天发现盲文就是一堆像素点，就想着用盲文文字在终端画图。&lt;/p&gt;
&lt;h2 id="实现效果"&gt;实现效果&lt;/h2&gt;
&lt;p&gt;&lt;img src="https://img2022.cnblogs.com/blog/2737337/202201/2737337-20220129095805294-258989594.jpg" alt="show1.png" loading="lazy"&gt;&lt;br&gt;
&lt;img src="https://img2022.cnblogs.com/blog/2737337/202201/2737337-20220129095805315-1934639186.jpg" alt="show2.png" loading="lazy"&gt;&lt;/p&gt;
&lt;h2 id="分析"&gt;分析&lt;/h2&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;⠀⠁⠂⠃⠄⠅⠆⠇⠈⠉⠊⠋⠌⠍⠎⠏
⠐⠑⠒⠓⠔⠕⠖⠗⠘⠙⠚⠛⠜⠝⠞⠟
⠠⠡⠢⠣⠤⠥⠦⠧⠨⠩⠪⠫⠬⠭⠮⠯
⠰⠱⠲⠳⠴⠵⠶⠷⠸⠹⠺⠻⠼⠽⠾⠿
⡀⡁⡂⡃⡄⡅⡆⡇⡈⡉⡊⡋⡌⡍⡎⡏
⡐⡑⡒⡓⡔⡕⡖⡗⡘⡙⡚⡛⡜⡝⡞⡟
⡠⡡⡢⡣⡤⡥⡦⡧⡨⡩⡪⡫⡬⡭⡮⡯
⡰⡱⡲⡳⡴⡵⡶⡷⡸⡹⡺⡻⡼⡽⡾⡿
⢀⢁⢂⢃⢄⢅⢆⢇⢈⢉⢊⢋⢌⢍⢎⢏
⢐⢑⢒⢓⢔⢕⢖⢗⢘⢙⢚⢛⢜⢝⢞⢟
⢠⢡⢢⢣⢤⢥⢦⢧⢨⢩⢪⢫⢬⢭⢮⢯
⢰⢱⢲⢳⢴⢵⢶⢷⢸⢹⢺⢻⢼⢽⢾⢿
⣀⣁⣂⣃⣄⣅⣆⣇⣈⣉⣊⣋⣌⣍⣎⣏
⣐⣑⣒⣓⣔⣕⣖⣗⣘⣙⣚⣛⣜⣝⣞⣟
⣠⣡⣢⣣⣤⣥⣦⣧⣨⣩⣪⣫⣬⣭⣮⣯
⣰⣱⣲⣳⣴⣵⣶⣷⣸⣹⣺⣻⣼⣽⣾⣿
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这是 UTF-8 中的盲文字符。共有 256 个。每个盲文字符都由数个点组成。点最多的盲文字符（右下角）有 8 个点，它看起来像个实心黑框框；点最少的盲文字符有 0 个点（左上角），虽然它看上去像个空格，但它真的和空格不是一个东西。&lt;/p&gt;
&lt;p&gt;稍微观察可以发现，一个盲文字符可以当成 4x2 的小形位图使用，如果能够良好组织，使盲文字符按某种方式排列，就可以拼出大一些的位图。&lt;/p&gt;
&lt;p&gt;不同的 4x2 位图共有 2^8 = 256 个，而不同的盲文字符正好也有 256 个。这意味着盲文字符和 4x2 的位图之间有着一一对应的关系。为了方便盲文与位图的与相转化，我们需要设计一种编码方案。&lt;/p&gt;
&lt;p&gt;上面列出的表显然是经过良好组织的，可以发现盲文字符的排布很有规律。找规律的过程略去不提，这里仅说编码方案。经过以下操作后，可以保证盲文字符和其对应的 4x2 位图有相同的编号：&lt;/p&gt;
&lt;p&gt;盲文：将上表中的盲文从上到下，从左到右依次编号 0 到 255 。&lt;/p&gt;
&lt;p&gt;位图：考虑搞一张权值表：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;1  8
2  16
4  32
64 128
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将表中所有对应位图黑色位置的权值加起来，得到的和即为位图的编号。&lt;/p&gt;
&lt;p&gt;例如，字符 “⢫” ，其编号为 171 ，其位图为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;1 1
1 0
0 1
0 1
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和权值表 py 后得到 1 + 8 + 2 + 32 + 128 = 171 ，和期待结果一致。&lt;/p&gt;
&lt;p&gt;使用这个方法，可以将 4x2 的小位图和它所对应的盲文字符的编号对应起来。于是，我们就可以在终端画图了。&lt;/p&gt;
&lt;h2 id="实现"&gt;实现&lt;/h2&gt;
&lt;p&gt;首先对盲文字符打表：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;const char *magic_table[] = {
	"⠀", "⠁", "⠂", "⠃", "⠄", "⠅", "⠆", "⠇", "⠈", "⠉", "⠊", "⠋", "⠌", "⠍", "⠎", "⠏",
	"⠐", "⠑", "⠒", "⠓", "⠔", "⠕", "⠖", "⠗", "⠘", "⠙", "⠚", "⠛", "⠜", "⠝", "⠞", "⠟",
	"⠠", "⠡", "⠢", "⠣", "⠤", "⠥", "⠦", "⠧", "⠨", "⠩", "⠪", "⠫", "⠬", "⠭", "⠮", "⠯",
	"⠰", "⠱", "⠲", "⠳", "⠴", "⠵", "⠶", "⠷", "⠸", "⠹", "⠺", "⠻", "⠼", "⠽", "⠾", "⠿",

	"⡀", "⡁", "⡂", "⡃", "⡄", "⡅", "⡆", "⡇", "⡈", "⡉", "⡊", "⡋", "⡌", "⡍", "⡎", "⡏",
	"⡐", "⡑", "⡒", "⡓", "⡔", "⡕", "⡖", "⡗", "⡘", "⡙", "⡚", "⡛", "⡜", "⡝", "⡞", "⡟",
	"⡠", "⡡", "⡢", "⡣", "⡤", "⡥", "⡦", "⡧", "⡨", "⡩", "⡪", "⡫", "⡬", "⡭", "⡮", "⡯",
	"⡰", "⡱", "⡲", "⡳", "⡴", "⡵", "⡶", "⡷", "⡸", "⡹", "⡺", "⡻", "⡼", "⡽", "⡾", "⡿",

	"⢀", "⢁", "⢂", "⢃", "⢄", "⢅", "⢆", "⢇", "⢈", "⢉", "⢊", "⢋", "⢌", "⢍", "⢎", "⢏",
	"⢐", "⢑", "⢒", "⢓", "⢔", "⢕", "⢖", "⢗", "⢘", "⢙", "⢚", "⢛", "⢜", "⢝", "⢞", "⢟",
	"⢠", "⢡", "⢢", "⢣", "⢤", "⢥", "⢦", "⢧", "⢨", "⢩", "⢪", "⢫", "⢬", "⢭", "⢮", "⢯",
	"⢰", "⢱", "⢲", "⢳", "⢴", "⢵", "⢶", "⢷", "⢸", "⢹", "⢺", "⢻", "⢼", "⢽", "⢾", "⢿",

	"⣀", "⣁", "⣂", "⣃", "⣄", "⣅", "⣆", "⣇", "⣈", "⣉", "⣊", "⣋", "⣌", "⣍", "⣎", "⣏",
	"⣐", "⣑", "⣒", "⣓", "⣔", "⣕", "⣖", "⣗", "⣘", "⣙", "⣚", "⣛", "⣜", "⣝", "⣞", "⣟",
	"⣠", "⣡", "⣢", "⣣", "⣤", "⣥", "⣦", "⣧", "⣨", "⣩", "⣪", "⣫", "⣬", "⣭", "⣮", "⣯",
	"⣰", "⣱", "⣲", "⣳", "⣴", "⣵", "⣶", "⣷", "⣸", "⣹", "⣺", "⣻", "⣼", "⣽", "⣾", "⣿"
};
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;接着实现 canvas 结构体。这里用 &lt;code&gt;unsigned char&lt;/code&gt; 数组当成 &lt;code&gt;bool&lt;/code&gt; 数组使用。日后优化时，可以用 bitmap 节省空间。&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;typedef struct canvas {
	int width;
	int height;
	void *buf;
} canvas;

int canvas_init(canvas *p, int width, int height)
{
	width = ((width - 1) / 2 + 1) * 2;
	height = ((height - 1) / 4 + 1) * 4;
	p-&amp;gt;width = width;
	p-&amp;gt;height = height;
	p-&amp;gt;buf = malloc(sizeof(unsigned char) * width * height);
	if (p-&amp;gt;buf == NULL)
		return 1;
	return 0;
}

void canvas_clear(canvas p)
{
	free(p.buf);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现画像素点和打印功能：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-c"&gt;void canvas_draw(canvas p, int x, int y)
{
	((unsigned char (*)[p.width])p.buf)[y][x] = 1;
}

void canvas_erase(canvas p, int x, int y)
{
	((unsigned char (*)[p.width])p.buf)[y][x] = 0;
}

int canvas_test(canvas p, int x, int y)
{
	return ((unsigned char (*)[p.width])p.buf)[y][x];
}

void canvas_print(canvas p)
{
	int i, j, k, l;
	for (i = p.height; i &amp;gt; 0; i -= 4) {
		for (j = 0; j &amp;lt; p.width; j += 2) {
			int id = 0;
			for (l = 1; l &amp;gt;= 0; --l)
				for (k = 3; k &amp;gt;= 1; --k)
					id = (id &amp;lt;&amp;lt; 1) | canvas_test(p, j + l, i - k);
			if (canvas_test(p, j, i - 4))
				id += 64;
			if (canvas_test(p, j + 1, i - 4))
				id += 128;
			printf("%s", magic_table[id]);
		}
		putchar('\n');
	}
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;实现完成。以下是函数功能与参数说明：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-plain"&gt;int canvas_init(canvas *p, int width, int height); 将 p 初始化为宽 width 高 height 的画布
void canvas_clear(canvas p); 销毁画布 p
void canvas_draw(canvas p, int x, int y); 在 p 的 (x, y) 位置画上一个像素点
void canvas_erase(canvas p, int x, int y); 擦除 p 中 (x, y) 位置上的像素点
int canvas_test(canvas p, int x, int y); 返回 p 中 (x, y) 上是否已经画过
void canvas_print(canvas p); 打印 p
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="实现示例中的效果"&gt;实现示例中的效果&lt;/h2&gt;
&lt;p&gt;用 ImageMagick 的 convert 命令将图片文件转为只有 2 种颜色的 xpm 文件，写个傻瓜 xpm 解析器，配合上面的代码简单处理即可得到示例中的效果。傻瓜解析器的代码见：&lt;a href="https://www.luogu.org/paste/npaqkp89" target="_blank" rel="noopener"&gt;doxpm.c&lt;/a&gt; 。&lt;/p&gt;
&lt;p&gt;在本机上，实现示例效果的命令为：&lt;/p&gt;
&lt;pre&gt;&lt;code class="language-bash"&gt;$ convert -colors 2 sample.png a.xpm
$ gcc doxpm.c -o doxpm
$ ./doxpm
$ # 如果需要彩色的话：
$ ./doxpm | lolcat
&lt;/code&gt;&lt;/pre&gt;
&lt;h2 id="完"&gt;完&lt;/h2&gt;
&lt;p&gt;代码仅被用来说明想法，并没有想写成一个可用的库。所以码风略快糙猛请多包涵。&lt;/p&gt;
&lt;p&gt;感谢 zrz_orz 同学教我在洛谷日报上投稿，并提出大量修改意见。&lt;/p&gt;

</content>
    <author>
      <name>jyi2ya</name>
    </author>
    <category term="note"/>
    <published>2022-01-25T23:03:00+08:00Z</published>
    <updated>2022-01-25T23:03:00+08:00Z</updated>
  </entry>
  <entry>
    <id>http://16435056370.774797416661695/</id>
    <title>重新开始写博客以及博客大迁移</title>
    <link rel="alternate" href="https://www.cnblogs.com/jyi2ya/p/15844753.html" type="text/html"/>
    <summary type="xhtml">
      <div xmlns="http://www.w3.org/1999/xhtml">重新开始 寒假打算重新写博客，发现洛谷的博客要爆炸不维护了，于是切换到博客园。</div>
    </summary>
    <content type="html">
&lt;h1 id="重新开始"&gt;重新开始&lt;/h1&gt;
&lt;p&gt;寒假打算重新写博客，发现洛谷的博客要爆炸不维护了，于是切换到博客园。&lt;/p&gt;
&lt;p&gt;&lt;img src="https://img2022.cnblogs.com/blog/2737337/202201/2737337-20220129095825975-1542361205.jpg" alt="" loading="lazy"&gt;&lt;/p&gt;

</content>
    <author>
      <name>jyi2ya</name>
    </author>
    <category term="note"/>
    <published>2022-01-25T22:56:00+08:00Z</published>
    <updated>2022-01-25T22:56:00+08:00Z</updated>
  </entry>
</feed>

